# 🖥 5장. 솔직히 말하자면

```
$5 + 10CHF = $10 (환율이 2:1일 경우)
```

이 테스트에 어떤 식으로 접근하는 게 좋을까? 작은 단계로 구현하는 테스트를 작성해낼 수 있을지 확실치 않다.

우선은 `Dollar`와 비슷하지만 달러 대신 프랑(Franc)을 표현할 수 있는 객체가 필요할 것 같다.

`Dollar` 객체와 비슷하게 작동하는 `Franc`이라는 객체를 만든다면 단위가 섞인 덧셈 테스트를 작성하고 돌려보는 데 더 가까워 질 것이다.

`Dollar` 테스트를 복사한 후 수정해보자.

&nbsp;

```java
@Test
@DisplayName("프랑 금액을 주식 수에 곱한 금액을 반환한다.")
void testFrancMultiplication() {
    Franc five = new Franc(5);
    assertEquals(five.times(2), new Dollar(10));
    assertEquals(five.times(3), new Dollar(15));
}
```

이제 `Dollar` 코드를 복사해서 `Dollar`를 `Franc`으로 바꾸면 어떨까.

*복사와 붙여넣기를 통한 재사용? ...*

1. 테스트 작성
2. 컴파일 되게 하기
3. 실패하는지 확인하기 위해 실행
4. 실행하게 만듦
5. 중복 제거

각 단계에는 서로 다른 목적이 있다. 다른 스타일의 해법을 필요로 한다.  

***처음 네 단계는 빠르게 진행 해야 한다.***  

그러면 새 기능이 포함되더라도 잘 알고 있는 상태에 이를 수 있다.  
거기에 도달하기 위해서는 어떤 죄든 저지를 수 있다. 그동안 만큼은 속도가 설꼐보다 더 높은 패이기 때문이다.

&nbsp;

**Franc**

```java
public class Franc {
    private int amount;

    public Franc(int amount) {
        this.amount = amount;
    }

    public Franc times(int multiplier) {
        return new Franc(amount * multiplier);
    }

    public boolean equals(Object object) {
        Franc franc = (Franc) object;
        return this.amount == franc.amount;
    }
}
```

중복이 엄청나게 많기 때문에 다음 테스트를 작성하기 전에 이것들을 제거해야 한다.

`equals()`를 일반화 하는 것 부터 시작하자.

할일 목록에 두 가지 항목(공용 `equals()`, 공용 `times()`)를 추가해야 하지만 한 가지 항목을 지울 수 있다.

&nbsp;

### 정리

- 큰 테스트는 공략할 수 없다. 그래서 진전을 나타낼 수 있는 자그마한 테스트를 만들었다.
- 뻔뻔스럽게도 중복을 만들고 조금 고쳐서 테스트를 작성했다.
- 모델 코드까지 복사하고 수정해서 테스트를 통과했다.
- 중복이 사라지기 전에는 집에 가지 않겠다고 약속했다.

&nbsp;

## 🖥 느낀점

'통화가 다른 두 금액을 더해서 주어진 화율에 맞게 변환한 금액을 결과로 얻을 수 있는 테스트'를 작성하기 위해,  
`Dollar` 외의 `Franc`을 설계함으로써 단위가 다른 새로운 화폐 객체를 만든 점이 인상 깊었다.

여기서 `Franc`은 기존의 `Dollar` 코드를 그대로 복사 붙여넣기 했는데, 뻔뻔스럽게 중복을 만들고 우선 돌아가게 만드는 점이 재밌었다. 

단위가 다른 새로운 화폐 객체를 만드니 `times()`와 `equals()` 같이 중복된 함수들이 눈에 보였다.  
기존에 `Dollar` 객체만 존재할 때는, 이들을 분리할 생각을 하지 못 했는데, 새 화폐 객체를 만드니 이들이 중복된 로직이라는 점을 알 수 있었다.  
역시 중복된 로직을 하나로 끄집어내는 일엔 객체를 이용하는 것이 최고인 것 같다.
