
### 테스트 주도 개발(TDD)의 리듬

1. 재빨리 테스트를 하나 추가한다.
2. 모든 테스트를 실행하고 새로 추가한 것이 실패하는지 확인한다.
3. 코드를 조금 바꾼다.
4. 모든 테스트를 실행하고 전부 성공하는지 확인한다.
5. 리팩토링을 통해 중복을 제거한다.

&nbsp;

# 🖥 1장. 다중 통화를 지원하는 Money 객체

### 요구사항

- 통화가 다른 두 금액을 더해서 주어진 환율에 맞게 변한 금액을 결과로 얻을 수 있어야 한다.
- 어떤 금액(주가)을 어떤 수(주식의 수)에 곱한 금액을 결과로 얻을 수 있어야 한다.

&nbsp;

### 테스트

첫 번째 테스트는 복잡해 보인다. 다음 항목인 곱하기는 어렵지 않아 보인다.

```java
@SpringBootTest
public class 다중통화 {
    @Test
    @DisplayName("금액을 주식 수에 곱한 금액을 반환한다.")
    void testMultiplication() {
        Dollor five = new Dollor(5);
        five.times(2);
        assertThat(10).isEqualTo(five.amount);
    }
}
```

**문제점**

- 컴파일 조차 되지 않는다.
- public field인 `amount`를 사용한다.
- 금액을 계산할 때 파라미터로 정수형을 넣는다.
- `Dollor` 객체의 부작용이 있을 수 있다.

→ 최대한 빨리 초록 막대를 보고싶다.

**네 개의 컴파일 에러**

- `Dollor` 클래스가 없음
- 생성자가 없음
- `times(int)` 메서드가 없음
- `amount` 필드가 없음

→ 한 번에 하나씩 정복한다. `Dollor` 클래스를 정의하면 에러 하나는 없앨 수 있다.

1. Dollar 클래스 정의

    ```java
    public class Dollar {

    }
    ```

    에러 하나는 없앨 수 있다.

2. 생성자 만들기

    ```java
    public Dollar(int amount) {

    }
    ```

    컴파일만 되게 할 거니까 생성자 안에서는 아무 일도 안 해도 된다.

3. `times()` 스텁 구현

    *스텁 구현 (stub implementation)*: 메서드의 서명 부와 반환 명령만 적어 메서드를 호출하는 코드(이 경우엔 테스트 코드)가 컴파일 될 수 있도록 껍데기만 만들어두는 것

    ```java
    public void times(int multiplier) {
            
    }
    ```

4. `amount` 필드 추가

    ```java
    int amount;
    ```

이제 테스트를 실행해서 테스트가 실패하는 모습을 볼 수 있게 됐다.

결과로 '10'이 나와야 하는데 '0'이 나왔다.

```java
int amount = 10;
```

&nbsp;

### 잊지 말아야 할 것

1. 작은 테스트 하나를 추가한다.
2. 테스트를 실행해서 테스트가 실패하는 것을 확인한다.
3. 조금 수정한다.
4. 테스트가 성공하는 것을 확인한다.
5. 중복을 제거하기 위해 리팩토링을 한다.

> **리팩토링 ?**  
코드의 외적 행위는 그대로 유지하면서 내부 구조를 변경하는 작업

&nbsp;

## 의존성과 중복

> 테스트와 코드 간의 문제는 중복이 아니라, 테스트와 코드 사이에 존재하는 의존성이다.

즉, 코드나 테스트 중 한쪽을 수정하면 반드시 다른 한쪽도 수정해야 하는 것이다.  
목표는 코드를 바꾸지 않으면서도 의미 있는 테스트를 하나 더 작성하는 것인데, 현재의 구현으로는 불가능하다.

의존성은 소프트웨어 개발의 모든 부분에서 문제 그 자체다.  
만약 특정 데이터베이스 벤더가 제공하는 세세한 기능들을 코드 여기저기에서 사용하는 상황에서 데이터베이스를 다른 벤더의 제품으로 변경하고자 한다면 코드가 해당 벤더에 대해 의존성을 갖는다는 것을 알게 된다.  
코드를 변경하지 않고는 벤더를 바꿀 수 없다.

> 중복을 제거함으로써, 의존성을 제거한다.

의존성이 문제 그 자체라면 중복은 문제의 징후다.  
중복의 가장 흔한 예는 **로직의 중복**이다.  
중복된 로직이란 동일한 문장이 코드의 여러 장소에 나타나는 것을 의미한다.  
중복된 로직을 하나로 끄집어내는 일엔 객체를 이용하는 것이 최고다.

프로그램에서는 중복만 제거해주면 의존성도 제거된다. 이게 바로 TDD 두 번째 규칙의 이유다.  
다음 테스트로 진행하기 전에 중복을 제거함으로써, 오직 한 가지의 코드 수정을 통해 다음 테스트도 통과되게 만들 가능성을 최대화 하는 것이다.

&nbsp;

### 중복 제거

테스트에 있는 데이터와 코드에 있는 데이터 사이의 중복을 찾아야 한다.

5와 2가 두 곳에 존대한다. 따라서 우린 이 중복을 제거해야 한다.

```java
void times(int multiplier) {
		amount = 5 * 2;
}
```

5를 어디서 얻을 수 있을까?  
이건 생성자에서 넘어오는 값이니 이걸 다음과 같이 `amount` 변수에 저장하면 `times`에서 사용할 수 있다.

```java
public Dollar(int amount) {
    this.amount = amount;
}

public void times(int multiplier) {
    amount = amount * 2;
}
```

인자 `multiplier`의 값이 2이므로, 상수를 이 인자로 대체할 수 있다.

```java
public void times(int multiplier) {
    amount = amount * multiplier;
}
```

마지막 중복을 제거한다.

```java
public void times(int multiplier) {
    amount *= multiplier;
}
```
